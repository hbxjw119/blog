---
title: tcp 和 http
date: 2017-09-10 19:14:35
tags: [tcp, http]
category: [Tech]
---

在经典的计算机网络 ISO 七层模型中，最接近用户的，是应用层，其次是传输层。应用层中，HTTP 是最重要的协议之一，而 TCP，则是传输层中，最重要的协议之一，这里整理下这两个协议的相关知识。
<!--more-->

## TCP

TCP 在传输层中实现，它是一个面向连接的协议，面向连接是相对于 UDP 这种无连接而言，具体说来，就是客户端和服务端传数据之前，会经过一个称为三次握手的过程。由于 TCP 是传输层协议，因此三次握手也是发生在传输层，**传输层利用网络层提供的功能，向上层提供可靠的服务，注意这个可靠二字。TCP 通过一系列的措施，如确认号，重传等机制，处理传输过程中丢失、超时、数据错误的问题，保证了可靠二字。**

### 三次握手

先来看看建立 TCP 时，发生的三次握手示意图，从上往下看，以时间轴为参照。
![三次握手](/images/tcp-three-handshakes.jpg)

**第一次握手**：建立 TCP 连接的发起者是客户端，客户端 TCP 先将 SYN 同步序列号置 1，说明这是一个连接请求，并随机选择一个初始序号（client_isn）并将其放置在起始的TCP SYN报文段的序号字段中（seq），然后客户端进入到 SYN-SENT 状态

**第二次握手**：服务器收到了 TCP SYN 报文段，会为该 TCP 分配 TCP 缓存和变量,首先，服务端也将自己的 SYN 置为 1，然后，该 TCP 的首部确认字段（ACK）被置为 client_isn+1，也就是告诉客户端：“我收到了，你能收到我的吗？”。最后，服务器也选择自己的初始序号（server_isn），并将其放在 TCP 报文段首部的序号字段中，一并发给客户端，这时服务器进入到 SYN_RCVD 状态。

**第三次握手**：客户端在收到服务器的 SYN ACK 报文段后，客户端也给该连接分配缓存和变量。客户端首先会将 server_isn+1,放置到 TCP 报文段首部来确认服务器的允许连接（ack=server+1）。因为连接实际已经建立了，因此 SYN 被置0。同时也置 ACK=1，这个报文发出去后，客户端进入到 ESTABLISHED 状态。服务端收到报文，也进入到 ESTABLISHED 状态。

三次握手完成后，客户端和服务器就已经建立了一条可靠的 TCP 连接信道，双方可以正常收发数据了。

### 四次挥手

说完了建立连接时的三次握手，再来看下断开连接时的四次挥手,先看下图，需要注意的是，不同于上面的客户端和服务器，TCP 的建立时，都是由客户端主动发起连接请求的，而 **TCP 的断开，可以是任意一方发起，也就是说服务端也可以主动要求关闭，即只有主动关闭和被动关闭**，网上很多博客文章里，草草的把挥手时的发起方写为客户端，会让人以为只有客户端才能关闭连接，有很大的误导性。为了消除这种误导，下面在说明断开连接时，只写主动关闭方和被动关闭方。
先看下四次挥手示意图，从上往下看，以时间轴为参照。
![四次挥手](/images/tcp-four-handshakes.jpg)

**第一次挥手**：当要断开 TCP 连接时，主动关闭方会发 FIN=1，seq=u（相当于前面已经传过去的最后一个字节的序号+1）的报文，表示自己已经没有数据需要发送，想关闭 TCP 连接了，然后自己进入 FIN-WAIT-1 状态，等待对方确认。

**第二次挥手**：被动关闭方收到报文后，马上发出确认 ACK=1，这个报文段自己的序号 seq=v（相当于服务端前面已经传送过的最后一个字节的序号+1），但发出去 ACK 后，它还不能马上就关闭连接，因为虽然对方没有数据要发了，但可能自己还有数据要发。因此当发完 ACK 后，被动关闭方会进入 CLOSE-WAIT 状态，表示“我知道你要关闭连接了，稍等下，我还有点数据要发”。
主动关闭方收到来自对方的 ACK 后，就进入了 FIN-WAIT-2 状态。

**第三次挥手**：若被动关闭方已经没数据要发了，那么它就要发 FIN=1 的连接释放报文，假定当前最后一次确认发送的序号为w（seq=w），并且需要重复发送上次确认过的确认号 ack=u+1。这时它就进入 LAST-ACK 状态，等待对方最后确认。

**第四次挥手**：主动关闭方收到对方的连接释放 FIN 后，在确认号中把 ACK 置为1，确认号是 ack=w+1，而自己的序号仍然是 seq=u+1。发出去后，它就进入 TIME-WAIT 状态。为了保证对方收到这个报文，它会等待一段时间，被称为 2MSL，一般是 30 秒，之后进入 CLOSED 状态，并且释放 TCP 所有资源，而被动关闭方收到 ACK 报文后，也进入到 CLOSED 状态。至此，TCP 连接完全断开。


### 几个问题
#### 1. 为什么要 4 次挥手呢?
被动关闭方收到 FIN 请求后，并不会马上关闭连接，因为它可能还有数据要发送，所以不能和建立连接时那样，直接发送 ACK 和 SYN，只能先回复一个 ACK，表示你的关闭请求（FIN）已经收到了，让我把剩下的东西传完。传完后，才能发送 FIN 报文，从而关闭 TCP 连接。

#### 2. 为什么 TIME-WAIT 状态需要等 2MSL 后才能到 CLOSED 状态？
这是因为虽然双方都同意关闭连接了，而且握手的 4 个报文也都协调和发送完毕，按理可以直接回到 CLOSED 状态（就好比从 SYN_SEND 状态到 ESTABLISH 状态那样）；但是因为我们必须要假想网络是不可靠的，主动关闭方不能保证最后发送的 ACK 报文会一定被对方收到，假如这个 ACK 真的丢了，那么被动关闭方会因为没收到 ACK，而重发 FIN 报文，假如主动关闭方没有 TIME-WAIT，而是发完 ACK 就直接关闭，那这时对方重发过来的 FIN 就无法再收到了，因为连接都关了。所以这个 TIME-WAIT 状态的作用就是保证最后的这个 ACK 能被对方收到，万一这个 ACK 丢失了，因为连接还没断，所以还可以用来重发这个丢失的 ACK 报文。

### 小结
上面介绍了 TCP 的建立和关闭握手过程，以及发送的报文和对应的状态。重点需要关注的是它们的状态流转过程。
 
## HTTP

http 是一个应用层协议，它基于 TCP，因此在客户端每发一次向服务器发 HTTP 请求之前，都需要完成上述的 TCP 三次握手。因此，http 不用关注传输的数据的正确，顺序等。http 也看不到三次握手的过程。首先看下一次完成的 http 请求和响应过程。
```
$ telnet www.baidu.com 80
Trying 115.239.211.112...
Connected to www.baidu.com.
Escape character is '^]'.
GET / HTTP/1.1
Host:www.baidu.com

HTTP/1.1 200 OK
Date: Thu, 19 Oct 2017 03:24:00 GMT
Content-Type: text/html
Content-Length: 14613
Last-Modified: Mon, 16 Oct 2017 03:26:00 GMT
Connection: Keep-Alive
Vary: Accept-Encoding
Set-Cookie: BAIDUID=BEC982B09B4F29890400AF959901E5DA:FG=1; expires=Thu, 31-Dec-37  domain=.baidu.com
Set-Cookie: BIDUPSID=BEC982B09B4F29890400AF959901E5DA; expires=Thu, 31-Dec-37 23:5ain=.baidu.com
Set-Cookie: PSTM=1508383440; expires=Thu, 31-Dec-37 23:55:55 GMT; max-age=21474836
P3P: CP=" OTI DSP COR IVA OUR IND COM "
Server: BWS/1.1
X-UA-Compatible: IE=Edge,chrome=1
Pragma: no-cache
Cache-control: no-cache
Accept-Ranges: bytes

<!DOCTYPE html><!--STATUS OK-->
<html>
<head>
...
```
由上面可以看到，一次完整的http过程，包括两个部分：**请求** 和**响应** 两个部分。
![请求和响应](/images/http-request-response.jpg)
### 请求
http请求由三部分构成：请求行，请求头，请求正文
##### 请求行
请求行用来说明请求类型，要访问的资源，以及使用的http版本。基本格式如下：Method URI Http-version
如上面的：
```
GET / HTTP/1.1
```

##### 请求头
紧挨这请求行（即第一行）之后的部分，用来说明服务器需要使用的附加信息，例如Host,User-Agent,Accept,Cookie等信息，每行都是以一个`k:v`的形式组成。服务器可以通过这些信息，来判断客户端的来源以及做些身份鉴别等。

##### 请求正文
在请求行和请求头完了后，空两行，就是请求正文了，包括要传递给服务器的各种参数等。

### 响应
http响应也由三部分构成：状态行，响应头，响应体
##### 状态行
状态行由 HTTP 协议版本号， 状态码， 状态消息 三部分组成，如上面所示：
```
HTTP/1.1 200 OK
```

##### 响应头
用来说明客户端需要的一些附加信息，如Content-Length，Date，Server等，格式也是以`k:v`形式返回。

##### 响应体
服务器返回的响应正文

综上，可以看到，请求和响应的基本格式，除了起始行有所不同外，其余的头部，正文两部分格式是相同的。

### HTTP 状态码
来看下响应状态行中的状态码，状态码有三位数字组成，第一个数字定义了响应的类别，共分五种类别:

1xx：指示信息--表示请求已接收，继续处理

2xx：成功--表示请求已被成功接收、理解、接受

3xx：重定向--要完成请求必须进行更进一步的操作

4xx：客户端错误--请求有语法错误或请求无法实现

5xx：服务器端错误--服务器未能实现合法的请求

常见状态码：

>200 OK                        //客户端请求成功
>301 Moved Permanently         //永久跳转，如将 80 端口的 http 请求永久跳转到 443 端口的 https
>302 Found                     //临时跳转
>400 Bad Request               //客户端请求有语法错误，不能被服务器所理解
>401 Unauthorized              //请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用 
>403 Forbidden                 //服务器收到请求，但是拒绝提供服务
>404 Not Found                 //请求资源不存在，eg：输入了错误的URL
>500 Internal Server Error     //服务器发生不可预期的错误
>502 Bad Gateway               //作为网关的服务器，如nginx，从后端服务收到一个无效响应
>503 Server Unavailable        //服务不可用，服务器当前不能处理客户端的请求，一段时间后可能恢复正常
>504 Gateway time-out          //作为网关服务器，如nginx，请求后端服务超时 

参考
* http://blog.csdn.net/hjtl1992/article/details/68944455
* https://jiajunhuang.com/articles/2017_10_14-web_dev_part2.md.html
* 《http权威指南》
